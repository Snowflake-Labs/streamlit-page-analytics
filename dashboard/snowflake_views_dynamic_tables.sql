-- Copyright 2025 Snowflake Inc.
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- SIMPLIFIED Dynamic Tables Implementation for Streamlit Page Analytics
--
-- This file defines the processing for user journey analytics using log data
-- and materializes it into optimized tables for Streamlit dashboard visualization.
-- The solution uses multiple Snowflake Dynamic Tables for maximum efficiency 
--
--Benefits of Dynamic Tables approach:
--
-- 1. No manual stream/task management - automatic dependency tracking
-- 2. Simpler code - SQL queries instead of stored procedures
-- 3. Automatic incremental refresh with LAG specification
-- 4. Built-in error handling and retry logic
-- 5. Automatic optimization of refresh strategies
-- 6. No warehouse management needed (serverless by default)
-- 7. Automatic dependency resolution between dynamic tables

-- =============================================================================
-- CONFIGURATION VARIABLES: Set names for your environment
-- =============================================================================

-- Configure the source table and target schema
SET STREAMLIT_LOGS_TABLE = 'SNOWFLAKE.TELEMETRY.EVENTS'; -- Update to your events table
SET ANALYTICS_SCHEMA = 'STREAMLIT_ANALYTICS';  -- Schema for materialized analytics tables

-- =============================================================================
-- SCHEMA SETUP
-- =============================================================================

USE SCHEMA IDENTIFIER($ANALYTICS_SCHEMA);

-- =============================================================================
-- DYNAMIC TABLES: Automated incremental processing pipeline
-- =============================================================================

-- Dynamic Table 1: USER_EVENTS
-- Processes raw logs with automatic incremental refresh every 10 minutes
CREATE OR REPLACE DYNAMIC TABLE USER_EVENTS
    TARGET_LAG = '10 minutes'  -- Refresh when source data is 10+ minutes old
    WAREHOUSE = 'COMPUTE_WH'   -- Or use serverless: USER_TASK_MANAGED_INITIAL_WAREHOUSE_SIZE = 'XSMALL'
    COMMENT = 'Dynamic table for processed user events with automatic incremental refresh'
AS
SELECT 
    DATE(TIMESTAMP) AS EVENT_DATE,
    TIMESTAMP,
    LOG_LEVEL,
    LOGGER_NAME,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'session_id') AS SESSION_ID,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'user_id') AS USER_ID,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'action') AS ACTION,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'id') AS WIDGET_ID,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'type') AS WIDGET_TYPE,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'label') AS WIDGET_LABEL,
    TRY_PARSE_JSON(JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'values', 'current')) AS WIDGET_CURRENT_VALUE,
    TRY_PARSE_JSON(JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'values', 'previous')) AS WIDGET_PREVIOUS_VALUE,
    TRY_PARSE_JSON(JSON_EXTRACT_PATH_TEXT(MESSAGE, 'extra')) AS EXTRA_DATA,
    TRY_PARSE_JSON(JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'extra')) AS WIDGET_EXTRA_DATA,
    PARSE_JSON(MESSAGE) AS ORIGINAL_EVENT_JSON,
    ROW_NUMBER() OVER (PARTITION BY JSON_EXTRACT_PATH_TEXT(MESSAGE, 'session_id') 
                      ORDER BY TIMESTAMP) AS EVENT_SEQUENCE_IN_SESSION,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM IDENTIFIER($STREAMLIT_LOGS_TABLE)
WHERE JSON_EXTRACT_PATH_TEXT(MESSAGE, 'session_id') IS NOT NULL
    AND JSON_EXTRACT_PATH_TEXT(MESSAGE, 'action') IS NOT NULL;

-- Dynamic Table 2: WIDGET_INTERACTION_SUMMARY
-- Automatically refreshes when USER_EVENTS has new data (dependency tracking)
CREATE OR REPLACE DYNAMIC TABLE WIDGET_INTERACTION_SUMMARY
    TARGET_LAG = '15 minutes'  -- Allow 15 min lag for hourly aggregations
    WAREHOUSE = 'COMPUTE_WH'
    COMMENT = 'Dynamic table for widget interaction summaries with automatic hourly aggregation'
AS
SELECT 
    DATE_TRUNC('hour', TIMESTAMP) AS SUMMARY_HOUR,
    WIDGET_ID,
    WIDGET_TYPE,
    WIDGET_LABEL,
    COUNT(*) AS TOTAL_INTERACTIONS,
    COUNT(CASE WHEN ACTION = 'click' THEN 1 END) AS CLICK_COUNT,
    COUNT(CASE WHEN ACTION = 'change' THEN 1 END) AS CHANGE_COUNT,
    COUNT(CASE WHEN ACTION = 'submit' THEN 1 END) AS SUBMIT_COUNT,
    COUNT(CASE WHEN ACTION = 'other' THEN 1 END) AS OTHER_COUNT,
    COUNT(DISTINCT SESSION_ID) AS UNIQUE_SESSIONS,
    COUNT(DISTINCT USER_ID) AS UNIQUE_USERS,
    MIN(TIMESTAMP) AS FIRST_INTERACTION,
    MAX(TIMESTAMP) AS LAST_INTERACTION,
    AVG(EVENT_SEQUENCE_IN_SESSION) AS AVG_POSITION_IN_SESSION,
    MEDIAN(EVENT_SEQUENCE_IN_SESSION) AS MEDIAN_POSITION_IN_SESSION,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM USER_EVENTS  -- References the dynamic table above - automatic dependency
WHERE WIDGET_ID IS NOT NULL 
    AND WIDGET_ID != 'unknown'
GROUP BY DATE_TRUNC('hour', TIMESTAMP), WIDGET_ID, WIDGET_TYPE, WIDGET_LABEL;

-- Dynamic Table 3: HOURLY_USER_ACTIVITY_SUMMARY
-- Complex hourly aggregations with query history correlation
CREATE OR REPLACE DYNAMIC TABLE HOURLY_USER_ACTIVITY_SUMMARY
    TARGET_LAG = '20 minutes'  -- Allow more lag for complex aggregations
    WAREHOUSE = 'COMPUTE_WH'
    COMMENT = 'Dynamic table for hourly user activity summaries with query correlation'
AS
WITH hourly_events AS (
    SELECT 
        DATE_TRUNC('hour', TIMESTAMP) AS ACTIVITY_HOUR,
        COUNT(DISTINCT SESSION_ID) AS UNIQUE_SESSIONS,
        COUNT(DISTINCT USER_ID) AS UNIQUE_USERS,
        COUNT(*) AS TOTAL_EVENTS,
        COUNT(CASE WHEN ACTION = 'click' THEN 1 END) AS CLICK_EVENTS,
        COUNT(CASE WHEN ACTION = 'change' THEN 1 END) AS CHANGE_EVENTS,
        COUNT(CASE WHEN ACTION = 'submit' THEN 1 END) AS SUBMIT_EVENTS,
        COUNT(CASE WHEN ACTION = 'other' THEN 1 END) AS OTHER_EVENTS,
        COUNT(DISTINCT WIDGET_ID) AS UNIQUE_WIDGETS_USED
    FROM USER_EVENTS  -- References dynamic table - automatic dependency
    GROUP BY DATE_TRUNC('hour', TIMESTAMP)
),
session_stats AS (
    SELECT 
        session_activity_hour AS ACTIVITY_HOUR,
        AVG(session_event_count) AS AVG_EVENTS_PER_SESSION,
        MEDIAN(session_event_count) AS MEDIAN_EVENTS_PER_SESSION,
        MAX(session_event_count) AS MAX_EVENTS_IN_SESSION,
        AVG(session_duration_minutes) AS AVG_SESSION_DURATION_MINUTES
    FROM (
        SELECT 
            DATE_TRUNC('hour', TIMESTAMP) AS session_activity_hour,
            SESSION_ID,
            COUNT(*) AS session_event_count,
            DATEDIFF('minute', MIN(TIMESTAMP), MAX(TIMESTAMP)) AS session_duration_minutes
        FROM USER_EVENTS
        GROUP BY DATE_TRUNC('hour', TIMESTAMP), SESSION_ID
    )
    GROUP BY session_activity_hour
),
query_stats AS (
    SELECT 
        DATE_TRUNC('hour', START_TIME) AS QUERY_HOUR,
        COUNT(*) AS TOTAL_QUERIES_EXECUTED,
        AVG(TOTAL_ELAPSED_TIME) AS AVG_QUERY_EXECUTION_TIME_MS,
        COUNT(CASE WHEN EXECUTION_STATUS != 'SUCCESS' THEN 1 END) AS FAILED_QUERIES,
        ROUND((COUNT(CASE WHEN EXECUTION_STATUS = 'SUCCESS' THEN 1 END) * 100.0) / COUNT(*), 2) AS QUERY_SUCCESS_RATE_PCT
    FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(
        END_TIME_RANGE_START => DATEADD('day', -30, CURRENT_TIMESTAMP()),
        RESULT_LIMIT => 10000
    ))
    WHERE SESSION_ID IS NOT NULL
    GROUP BY DATE_TRUNC('hour', START_TIME)
)
SELECT 
    he.ACTIVITY_HOUR,
    he.UNIQUE_SESSIONS,
    he.UNIQUE_USERS,
    he.TOTAL_EVENTS,
    he.CLICK_EVENTS,
    he.CHANGE_EVENTS,
    he.SUBMIT_EVENTS,
    he.OTHER_EVENTS,
    he.UNIQUE_WIDGETS_USED,
    COALESCE(ss.AVG_EVENTS_PER_SESSION, 0) AS AVG_EVENTS_PER_SESSION,
    COALESCE(ss.MEDIAN_EVENTS_PER_SESSION, 0) AS MEDIAN_EVENTS_PER_SESSION,
    COALESCE(ss.MAX_EVENTS_IN_SESSION, 0) AS MAX_EVENTS_IN_SESSION,
    COALESCE(ss.AVG_SESSION_DURATION_MINUTES, 0) AS AVG_SESSION_DURATION_MINUTES,
    COALESCE(qs.TOTAL_QUERIES_EXECUTED, 0) AS TOTAL_QUERIES_EXECUTED,
    COALESCE(qs.AVG_QUERY_EXECUTION_TIME_MS, 0) AS AVG_QUERY_EXECUTION_TIME_MS,
    COALESCE(qs.FAILED_QUERIES, 0) AS FAILED_QUERIES,
    COALESCE(qs.QUERY_SUCCESS_RATE_PCT, 100) AS QUERY_SUCCESS_RATE_PCT,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM hourly_events he
LEFT JOIN session_stats ss ON he.ACTIVITY_HOUR = ss.ACTIVITY_HOUR
LEFT JOIN query_stats qs ON he.ACTIVITY_HOUR = qs.QUERY_HOUR;

-- Dynamic Table 4: USER_SESSION_JOURNEY
-- Enhanced session journey with automatic refresh
CREATE OR REPLACE DYNAMIC TABLE USER_SESSION_JOURNEY
    TARGET_LAG = '15 minutes'
    WAREHOUSE = 'COMPUTE_WH'
    COMMENT = 'Dynamic table for user session journey analysis'
AS
WITH session_windows AS (
    SELECT 
        SESSION_ID,
        USER_ID,
        MIN(TIMESTAMP) AS SESSION_START,
        MAX(TIMESTAMP) AS SESSION_END,
        COUNT(*) AS TOTAL_EVENTS_IN_SESSION
    FROM USER_EVENTS
    GROUP BY SESSION_ID, USER_ID
),
query_correlation AS (
    SELECT 
        qh.SESSION_ID,
        qh.QUERY_ID,
        qh.QUERY_TEXT,
        qh.START_TIME AS QUERY_START_TIME,
        qh.TOTAL_ELAPSED_TIME AS EXECUTION_TIME_MS,
        qh.ROWS_PRODUCED AS ROWS_RETURNED,
        qh.EXECUTION_STATUS AS QUERY_STATUS,
        qh.ERROR_MESSAGE,
        ROW_NUMBER() OVER (PARTITION BY qh.SESSION_ID ORDER BY qh.START_TIME) AS QUERY_SEQUENCE_IN_SESSION
    FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(
        END_TIME_RANGE_START => DATEADD('day', -30, CURRENT_TIMESTAMP())
    )) qh
    WHERE qh.SESSION_ID IS NOT NULL
)
SELECT 
    ue.EVENT_DATE AS SESSION_DATE,
    ue.SESSION_ID,
    ue.USER_ID,
    ue.TIMESTAMP AS EVENT_TIMESTAMP,
    ue.ACTION,
    ue.WIDGET_ID,
    ue.WIDGET_TYPE,
    ue.WIDGET_LABEL,
    ue.EVENT_SEQUENCE_IN_SESSION,
    DATEDIFF('second', 
             LAG(ue.TIMESTAMP) OVER (PARTITION BY ue.SESSION_ID ORDER BY ue.TIMESTAMP), 
             ue.TIMESTAMP) AS SECONDS_SINCE_LAST_EVENT,
    sw.SESSION_START,
    sw.SESSION_END,
    DATEDIFF('second', sw.SESSION_START, sw.SESSION_END) AS SESSION_DURATION_SECONDS,
    sw.TOTAL_EVENTS_IN_SESSION,
    qc.QUERY_ID,
    qc.QUERY_TEXT,
    qc.QUERY_START_TIME,
    qc.EXECUTION_TIME_MS,
    qc.ROWS_RETURNED,
    qc.QUERY_STATUS,
    qc.ERROR_MESSAGE,
    qc.QUERY_SEQUENCE_IN_SESSION,
    DATEDIFF('second', ue.TIMESTAMP, qc.QUERY_START_TIME) AS SECONDS_EVENT_TO_QUERY,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM USER_EVENTS ue
JOIN session_windows sw ON ue.SESSION_ID = sw.SESSION_ID
LEFT JOIN query_correlation qc ON ue.SESSION_ID = qc.SESSION_ID 
    AND qc.QUERY_START_TIME >= ue.TIMESTAMP 
    AND qc.QUERY_START_TIME <= DATEADD('second', 30, ue.TIMESTAMP);  -- Link queries within 30 seconds of events

-- Dynamic Table 5: USER_FUNNEL_ANALYSIS
CREATE OR REPLACE DYNAMIC TABLE USER_FUNNEL_ANALYSIS
    TARGET_LAG = '30 minutes'  -- Can have higher lag for funnel analysis
    WAREHOUSE = 'COMPUTE_WH'
    COMMENT = 'Dynamic table for user funnel analysis with automatic aggregation'
AS
WITH session_summary AS (
    SELECT 
        DATE_TRUNC('hour', MIN(TIMESTAMP)) AS ANALYSIS_HOUR,
        SESSION_ID,
        USER_ID,
        MIN(TIMESTAMP) AS SESSION_START,
        MAX(TIMESTAMP) AS SESSION_END,
        COUNT(*) AS TOTAL_EVENTS,
        MAX(CASE WHEN WIDGET_LABEL ILIKE '%login%' THEN 1 ELSE 0 END) AS COMPLETED_LOGIN,
        MAX(CASE WHEN WIDGET_LABEL ILIKE '%select%' OR ACTION = 'change' THEN 1 ELSE 0 END) AS COMPLETED_SELECTION,
        MAX(CASE WHEN WIDGET_LABEL ILIKE '%search%' THEN 1 ELSE 0 END) AS COMPLETED_SEARCH,
        MAX(CASE WHEN WIDGET_LABEL ILIKE '%download%' THEN 1 ELSE 0 END) AS COMPLETED_DOWNLOAD,
        MAX(CASE WHEN ACTION = 'submit' THEN 1 ELSE 0 END) AS COMPLETED_SUBMIT
    FROM USER_EVENTS
    GROUP BY SESSION_ID, USER_ID
)
SELECT 
    ANALYSIS_HOUR,
    SESSION_ID,
    USER_ID,
    SESSION_START,
    SESSION_END,
    TOTAL_EVENTS,
    COMPLETED_LOGIN::BOOLEAN,
    COMPLETED_SELECTION::BOOLEAN,
    COMPLETED_SEARCH::BOOLEAN,
    COMPLETED_DOWNLOAD::BOOLEAN,
    COMPLETED_SUBMIT::BOOLEAN,
    -- Calculate funnel score (0-5 based on completed steps)
    (COMPLETED_LOGIN + COMPLETED_SELECTION + COMPLETED_SEARCH + COMPLETED_DOWNLOAD + COMPLETED_SUBMIT) AS FUNNEL_SCORE,
    -- Determine drop-off stage
    CASE 
        WHEN COMPLETED_SUBMIT = 1 THEN 'COMPLETED'
        WHEN COMPLETED_DOWNLOAD = 1 THEN 'DROPPED_AT_SUBMIT'
        WHEN COMPLETED_SEARCH = 1 THEN 'DROPPED_AT_DOWNLOAD'
        WHEN COMPLETED_SELECTION = 1 THEN 'DROPPED_AT_SEARCH'
        WHEN COMPLETED_LOGIN = 1 THEN 'DROPPED_AT_SELECTION'
        ELSE 'DROPPED_AT_LOGIN'
    END AS DROP_OFF_STAGE,
    -- Step numbers (for funnel visualization)
    CASE WHEN COMPLETED_LOGIN = 1 THEN 1 ELSE NULL END AS LOGIN_STEP,
    CASE WHEN COMPLETED_SELECTION = 1 THEN 2 ELSE NULL END AS SELECTION_STEP,
    CASE WHEN COMPLETED_SEARCH = 1 THEN 3 ELSE NULL END AS SEARCH_STEP,
    CASE WHEN COMPLETED_DOWNLOAD = 1 THEN 4 ELSE NULL END AS DOWNLOAD_STEP,
    CASE WHEN COMPLETED_SUBMIT = 1 THEN 5 ELSE NULL END AS SUBMIT_STEP,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM session_summary;

-- =============================================================================
-- DASHBOARD VIEWS: 
-- =============================================================================

-- Dashboard view for time-based analysis
CREATE OR REPLACE VIEW VW_DASHBOARD_TIME_SERIES AS
SELECT 
    ACTIVITY_HOUR,
    DATE(ACTIVITY_HOUR) AS ACTIVITY_DATE,
    ACTIVITY_HOUR AS ACTIVITY_TIMESTAMP,
    UNIQUE_SESSIONS,
    UNIQUE_USERS,
    TOTAL_EVENTS,
    CLICK_EVENTS,
    CHANGE_EVENTS,
    SUBMIT_EVENTS,
    OTHER_EVENTS,
    AVG_EVENTS_PER_SESSION,
    AVG_SESSION_DURATION_MINUTES,
    TOTAL_QUERIES_EXECUTED,
    AVG_QUERY_EXECUTION_TIME_MS,
    QUERY_SUCCESS_RATE_PCT,
    -- Calculate hour-over-hour changes
    LAG(UNIQUE_SESSIONS) OVER (ORDER BY ACTIVITY_HOUR) AS PREV_UNIQUE_SESSIONS,
    LAG(TOTAL_EVENTS) OVER (ORDER BY ACTIVITY_HOUR) AS PREV_TOTAL_EVENTS,
    ROUND(((UNIQUE_SESSIONS - LAG(UNIQUE_SESSIONS) OVER (ORDER BY ACTIVITY_HOUR)) * 100.0 / 
           NULLIF(LAG(UNIQUE_SESSIONS) OVER (ORDER BY ACTIVITY_HOUR), 0)), 2) AS SESSIONS_CHANGE_PCT
FROM HOURLY_USER_ACTIVITY_SUMMARY  -- Now references dynamic table
ORDER BY ACTIVITY_HOUR DESC;

-- Dashboard view for widget analysis
CREATE OR REPLACE VIEW VW_DASHBOARD_WIDGET_ANALYSIS AS
SELECT 
    WIDGET_TYPE,
    WIDGET_LABEL,
    SUM(TOTAL_INTERACTIONS) AS TOTAL_INTERACTIONS,
    SUM(CLICK_COUNT) AS TOTAL_CLICKS,
    SUM(CHANGE_COUNT) AS TOTAL_CHANGES,
    COUNT(DISTINCT DATE(SUMMARY_HOUR)) AS ACTIVE_DAYS,
    COUNT(DISTINCT SUMMARY_HOUR) AS ACTIVE_HOURS,
    AVG(AVG_POSITION_IN_SESSION) AS AVG_POSITION_IN_SESSION,
    SUM(UNIQUE_SESSIONS) AS TOTAL_UNIQUE_SESSIONS,
    SUM(UNIQUE_USERS) AS TOTAL_UNIQUE_USERS,
    ROUND(SUM(TOTAL_INTERACTIONS) * 100.0 / NULLIF(SUM(UNIQUE_SESSIONS), 0), 2) AS ENGAGEMENT_RATE_PCT,
    SUM(CASE WHEN SUMMARY_HOUR >= DATEADD('day', -7, CURRENT_TIMESTAMP()) THEN TOTAL_INTERACTIONS ELSE 0 END) AS RECENT_INTERACTIONS,
    SUM(CASE WHEN SUMMARY_HOUR >= DATEADD('hour', -24, CURRENT_TIMESTAMP()) THEN TOTAL_INTERACTIONS ELSE 0 END) AS LAST_24H_INTERACTIONS
FROM WIDGET_INTERACTION_SUMMARY  -- Now references dynamic table
WHERE SUMMARY_HOUR >= DATEADD('day', -30, CURRENT_TIMESTAMP())
GROUP BY WIDGET_TYPE, WIDGET_LABEL
ORDER BY TOTAL_INTERACTIONS DESC;

-- Dashboard view for session analysis
CREATE OR REPLACE VIEW VW_DASHBOARD_SESSION_ANALYSIS AS
SELECT 
    SESSION_DATE,
    SESSION_ID,
    USER_ID,
    COUNT(*) AS EVENT_COUNT,
    MIN(EVENT_TIMESTAMP) AS SESSION_START,
    MAX(EVENT_TIMESTAMP) AS SESSION_END,
    DATEDIFF('minute', MIN(EVENT_TIMESTAMP), MAX(EVENT_TIMESTAMP)) AS SESSION_DURATION_MINUTES,
    COUNT(DISTINCT WIDGET_ID) AS UNIQUE_WIDGETS_INTERACTED,
    COUNT(CASE WHEN ACTION = 'click' THEN 1 END) AS CLICKS,
    COUNT(CASE WHEN ACTION = 'change' THEN 1 END) AS CHANGES,
    COUNT(CASE WHEN ACTION = 'submit' THEN 1 END) AS SUBMITS,
    MAX(CASE WHEN WIDGET_LABEL ILIKE '%login%' THEN 1 ELSE 0 END) AS HAS_LOGIN,
    MAX(CASE WHEN WIDGET_LABEL ILIKE '%search%' THEN 1 ELSE 0 END) AS HAS_SEARCH,
    MAX(CASE WHEN ACTION = 'submit' THEN 1 ELSE 0 END) AS HAS_SUBMIT
FROM USER_SESSION_JOURNEY  -- Now references dynamic table
WHERE SESSION_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY SESSION_DATE, SESSION_ID, USER_ID
ORDER BY SESSION_START DESC;

-- Dashboard view for real-time monitoring
CREATE OR REPLACE VIEW VW_DASHBOARD_REALTIME AS
SELECT 
    'today' AS PERIOD,
    COUNT(DISTINCT SESSION_ID) AS SESSIONS_TODAY,
    COUNT(*) AS EVENTS_TODAY,
    AVG(DATEDIFF('minute', MIN(TIMESTAMP), MAX(TIMESTAMP))) AS AVG_SESSION_DURATION_TODAY,
    COUNT(DISTINCT WIDGET_ID) AS WIDGETS_USED_TODAY
FROM USER_EVENTS  -- Now references dynamic table
WHERE EVENT_DATE = CURRENT_DATE()

UNION ALL

SELECT 
    'yesterday' AS PERIOD,
    COUNT(DISTINCT SESSION_ID) AS SESSIONS_YESTERDAY,
    COUNT(*) AS EVENTS_YESTERDAY,
    AVG(DATEDIFF('minute', MIN(TIMESTAMP), MAX(TIMESTAMP))) AS AVG_SESSION_DURATION_YESTERDAY,
    COUNT(DISTINCT WIDGET_ID) AS WIDGETS_USED_YESTERDAY
FROM USER_EVENTS
WHERE EVENT_DATE = DATEADD('day', -1, CURRENT_DATE())

UNION ALL

SELECT 
    'last_7_days' AS PERIOD,
    COUNT(DISTINCT SESSION_ID) AS SESSIONS_WEEK,
    COUNT(*) AS EVENTS_WEEK,
    AVG(DATEDIFF('minute', MIN(TIMESTAMP), MAX(TIMESTAMP))) AS AVG_SESSION_DURATION_WEEK,
    COUNT(DISTINCT WIDGET_ID) AS WIDGETS_USED_WEEK
FROM USER_EVENTS
WHERE EVENT_DATE >= DATEADD('day', -7, CURRENT_DATE());
