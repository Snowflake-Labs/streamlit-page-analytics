-- Copyright 2025 Snowflake Inc.
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- SIMPLIFIED Dynamic Tables Implementation for Streamlit Page Analytics
--
-- This file defines the processing for user journey analytics using log data
-- and materializes it into optimized tables for Streamlit dashboard visualization.
-- The solution uses multiple Snowflake Dynamic Tables for maximum efficiency 
--
--Benefits of Dynamic Tables approach:
--
-- 1. No manual stream/task management - automatic dependency tracking
-- 2. Simpler code - SQL queries instead of stored procedures
-- 3. Automatic incremental refresh with LAG specification
-- 4. Built-in error handling and retry logic
-- 5. Automatic optimization of refresh strategies
-- 6. No warehouse management needed (serverless by default)
-- 7. Automatic dependency resolution between dynamic tables

-- =============================================================================
-- CONFIGURATION VARIABLES: Set names for your environment
-- =============================================================================

-- Configure the source table and target schema
SET STREAMLIT_LOGS_TABLE = 'SNOWFLAKE.TELEMETRY.EVENTS'; -- Update to your events table
SET ANALYTICS_SCHEMA = 'STREAMLIT_ANALYTICS';  -- Schema for materialized analytics tables

-- =============================================================================
-- SCHEMA SETUP
-- =============================================================================

USE SCHEMA IDENTIFIER($ANALYTICS_SCHEMA);

-- =============================================================================
-- DYNAMIC TABLES: Automated incremental processing pipeline
-- =============================================================================

-- Dynamic Table 1: USER_EVENTS
-- Processes raw logs with automatic incremental refresh every 10 minutes
CREATE OR REPLACE DYNAMIC TABLE USER_EVENTS
TARGET_LAG = '10 minutes'  -- Refresh when source data is 10+ minutes old
WAREHOUSE = 'COMPUTE_WH'   -- Or use serverless: USER_TASK_MANAGED_INITIAL_WAREHOUSE_SIZE = 'XSMALL'
COMMENT = 'Dynamic table for processed user events with automatic incremental refresh'
AS
SELECT
    DATE(TIMESTAMP) AS EVENT_DATE,
    TIMESTAMP,
    LOG_LEVEL,
    LOGGER_NAME,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'session_id') AS SESSION_ID,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'user_id') AS USER_ID,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'action') AS USER_ACTION,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'id') AS WIDGET_ID,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'type') AS WIDGET_TYPE,
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'label') AS WIDGET_LABEL,
    TRY_PARSE_JSON(JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'values', 'current')) AS WIDGET_CURRENT_VALUE,
    TRY_PARSE_JSON(JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'values', 'previous')) AS WIDGET_PREVIOUS_VALUE,
    TRY_PARSE_JSON(JSON_EXTRACT_PATH_TEXT(MESSAGE, 'extra')) AS EXTRA_DATA,
    TRY_PARSE_JSON(JSON_EXTRACT_PATH_TEXT(MESSAGE, 'widget', 'extra')) AS WIDGET_EXTRA_DATA,
    PARSE_JSON(MESSAGE) AS ORIGINAL_EVENT_JSON,
    ROW_NUMBER() OVER (
        PARTITION BY JSON_EXTRACT_PATH_TEXT(MESSAGE, 'session_id')
        ORDER BY TIMESTAMP
    ) AS EVENT_SEQUENCE_IN_SESSION,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM IDENTIFIER($STREAMLIT_LOGS_TABLE)
WHERE
    JSON_EXTRACT_PATH_TEXT(MESSAGE, 'session_id') IS NOT NULL
    AND JSON_EXTRACT_PATH_TEXT(MESSAGE, 'action') IS NOT NULL;

-- Dynamic Table 2: WIDGET_INTERACTION_SUMMARY
-- Automatically refreshes when USER_EVENTS has new data (dependency tracking)
CREATE OR REPLACE DYNAMIC TABLE WIDGET_INTERACTION_SUMMARY
TARGET_LAG = '15 minutes'  -- Allow 15 min lag for hourly aggregations
WAREHOUSE = 'COMPUTE_WH'
COMMENT = 'Dynamic table for widget interaction summaries with automatic hourly aggregation'
AS
SELECT
    DATE_TRUNC('hour', TIMESTAMP) AS SUMMARY_HOUR,
    WIDGET_ID,
    WIDGET_TYPE,
    WIDGET_LABEL,
    COUNT(*) AS TOTAL_INTERACTIONS,
    COUNT(CASE WHEN USER_ACTION = 'click' THEN 1 END) AS CLICK_COUNT,
    COUNT(CASE WHEN USER_ACTION = 'change' THEN 1 END) AS CHANGE_COUNT,
    COUNT(CASE WHEN USER_ACTION = 'submit' THEN 1 END) AS SUBMIT_COUNT,
    COUNT(CASE WHEN USER_ACTION = 'other' THEN 1 END) AS OTHER_COUNT,
    COUNT(DISTINCT SESSION_ID) AS UNIQUE_SESSIONS,
    COUNT(DISTINCT USER_ID) AS UNIQUE_USERS,
    MIN(TIMESTAMP) AS FIRST_INTERACTION,
    MAX(TIMESTAMP) AS LAST_INTERACTION,
    AVG(EVENT_SEQUENCE_IN_SESSION) AS AVG_POSITION_IN_SESSION,
    MEDIAN(EVENT_SEQUENCE_IN_SESSION) AS MEDIAN_POSITION_IN_SESSION,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM USER_EVENTS  -- References the dynamic table above - automatic dependency
WHERE
    WIDGET_ID IS NOT NULL
    AND WIDGET_ID != 'unknown'
GROUP BY DATE_TRUNC('hour', TIMESTAMP), WIDGET_ID, WIDGET_TYPE, WIDGET_LABEL;

-- Dynamic Table 3: HOURLY_USER_ACTIVITY_SUMMARY
-- Complex hourly aggregations with query history correlation
CREATE OR REPLACE DYNAMIC TABLE HOURLY_USER_ACTIVITY_SUMMARY
TARGET_LAG = '20 minutes'  -- Allow more lag for complex aggregations
WAREHOUSE = 'COMPUTE_WH'
COMMENT = 'Dynamic table for hourly user activity summaries with query correlation'
AS
WITH
    HOURLY_EVENTS AS (
        SELECT
            DATE_TRUNC('hour', TIMESTAMP) AS ACTIVITY_HOUR,
            COUNT(DISTINCT SESSION_ID) AS UNIQUE_SESSIONS,
            COUNT(DISTINCT USER_ID) AS UNIQUE_USERS,
            COUNT(*) AS TOTAL_EVENTS,
            COUNT(CASE WHEN USER_ACTION = 'click' THEN 1 END) AS CLICK_EVENTS,
            COUNT(CASE WHEN USER_ACTION = 'change' THEN 1 END) AS CHANGE_EVENTS,
            COUNT(CASE WHEN USER_ACTION = 'submit' THEN 1 END) AS SUBMIT_EVENTS,
            COUNT(CASE WHEN USER_ACTION = 'other' THEN 1 END) AS OTHER_EVENTS,
            COUNT(DISTINCT WIDGET_ID) AS UNIQUE_WIDGETS_USED
        FROM USER_EVENTS  -- References dynamic table - automatic dependency
        GROUP BY DATE_TRUNC('hour', TIMESTAMP)
    ),

    SESSION_STATS AS (
        SELECT
            SESSION_ACTIVITY_HOUR AS ACTIVITY_HOUR,
            AVG(SESSION_EVENT_COUNT) AS AVG_EVENTS_PER_SESSION,
            MEDIAN(SESSION_EVENT_COUNT) AS MEDIAN_EVENTS_PER_SESSION,
            MAX(SESSION_EVENT_COUNT) AS MAX_EVENTS_IN_SESSION,
            AVG(SESSION_DURATION_MINUTES) AS AVG_SESSION_DURATION_MINUTES
        FROM (
            SELECT
                DATE_TRUNC('hour', TIMESTAMP) AS SESSION_ACTIVITY_HOUR,
                SESSION_ID,
                COUNT(*) AS SESSION_EVENT_COUNT,
                DATEDIFF('minute', MIN(TIMESTAMP), MAX(TIMESTAMP)) AS SESSION_DURATION_MINUTES
            FROM USER_EVENTS
            GROUP BY DATE_TRUNC('hour', TIMESTAMP), SESSION_ID
        )
        GROUP BY SESSION_ACTIVITY_HOUR
    ),

    QUERY_STATS AS (
        SELECT
            DATE_TRUNC('hour', START_TIME) AS QUERY_HOUR,
            COUNT(*) AS TOTAL_QUERIES_EXECUTED,
            AVG(TOTAL_ELAPSED_TIME) AS AVG_QUERY_EXECUTION_TIME_MS,
            COUNT(CASE WHEN EXECUTION_STATUS != 'SUCCESS' THEN 1 END) AS FAILED_QUERIES,
            ROUND((COUNT(CASE WHEN EXECUTION_STATUS = 'SUCCESS' THEN 1 END) * 100.0) / COUNT(*), 2)
                AS QUERY_SUCCESS_RATE_PCT
        FROM
            TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(
                END_TIME_RANGE_START => DATEADD('day', -30, CURRENT_TIMESTAMP()),
                RESULT_LIMIT => 10000
            ))
        WHERE SESSION_ID IS NOT NULL
        GROUP BY DATE_TRUNC('hour', START_TIME)
    )

SELECT
    HE.ACTIVITY_HOUR,
    HE.UNIQUE_SESSIONS,
    HE.UNIQUE_USERS,
    HE.TOTAL_EVENTS,
    HE.CLICK_EVENTS,
    HE.CHANGE_EVENTS,
    HE.SUBMIT_EVENTS,
    HE.OTHER_EVENTS,
    HE.UNIQUE_WIDGETS_USED,
    COALESCE(SS.AVG_EVENTS_PER_SESSION, 0) AS AVG_EVENTS_PER_SESSION,
    COALESCE(SS.MEDIAN_EVENTS_PER_SESSION, 0) AS MEDIAN_EVENTS_PER_SESSION,
    COALESCE(SS.MAX_EVENTS_IN_SESSION, 0) AS MAX_EVENTS_IN_SESSION,
    COALESCE(SS.AVG_SESSION_DURATION_MINUTES, 0) AS AVG_SESSION_DURATION_MINUTES,
    COALESCE(QS.TOTAL_QUERIES_EXECUTED, 0) AS TOTAL_QUERIES_EXECUTED,
    COALESCE(QS.AVG_QUERY_EXECUTION_TIME_MS, 0) AS AVG_QUERY_EXECUTION_TIME_MS,
    COALESCE(QS.FAILED_QUERIES, 0) AS FAILED_QUERIES,
    COALESCE(QS.QUERY_SUCCESS_RATE_PCT, 100) AS QUERY_SUCCESS_RATE_PCT,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM HOURLY_EVENTS AS HE
    LEFT JOIN SESSION_STATS AS SS ON HE.ACTIVITY_HOUR = SS.ACTIVITY_HOUR
    LEFT JOIN QUERY_STATS AS QS ON HE.ACTIVITY_HOUR = QS.QUERY_HOUR;

-- Dynamic Table 4: USER_SESSION_JOURNEY
-- Enhanced session journey with automatic refresh
CREATE OR REPLACE DYNAMIC TABLE USER_SESSION_JOURNEY
TARGET_LAG = '15 minutes'
WAREHOUSE = 'COMPUTE_WH'
COMMENT = 'Dynamic table for user session journey analysis'
AS
WITH
    SESSION_WINDOWS AS (
        SELECT
            SESSION_ID,
            USER_ID,
            MIN(TIMESTAMP) AS SESSION_START,
            MAX(TIMESTAMP) AS SESSION_END,
            COUNT(*) AS TOTAL_EVENTS_IN_SESSION
        FROM USER_EVENTS
        GROUP BY SESSION_ID, USER_ID
    ),

    QUERY_CORRELATION AS (
        SELECT
            QH.SESSION_ID,
            QH.QUERY_ID,
            QH.QUERY_TEXT,
            QH.START_TIME AS QUERY_START_TIME,
            QH.TOTAL_ELAPSED_TIME AS EXECUTION_TIME_MS,
            QH.ROWS_PRODUCED AS ROWS_RETURNED,
            QH.EXECUTION_STATUS AS QUERY_STATUS,
            QH.ERROR_MESSAGE,
            ROW_NUMBER() OVER (PARTITION BY QH.SESSION_ID ORDER BY QH.START_TIME) AS QUERY_SEQUENCE_IN_SESSION
        FROM
            TABLE(INFORMATION_SCHEMA.QUERY_HISTORY(
                END_TIME_RANGE_START => DATEADD('day', -30, CURRENT_TIMESTAMP())
            )) AS QH
        WHERE QH.SESSION_ID IS NOT NULL
    )

SELECT
    UE.EVENT_DATE AS SESSION_DATE,
    UE.SESSION_ID,
    UE.USER_ID,
    UE.TIMESTAMP AS EVENT_TIMESTAMP,
    UE.USER_ACTION,
    UE.WIDGET_ID,
    UE.WIDGET_TYPE,
    UE.WIDGET_LABEL,
    UE.EVENT_SEQUENCE_IN_SESSION,
    DATEDIFF(
        'second',
        LAG(UE.TIMESTAMP) OVER (PARTITION BY UE.SESSION_ID ORDER BY UE.TIMESTAMP),
        UE.TIMESTAMP
    ) AS SECONDS_SINCE_LAST_EVENT,
    SW.SESSION_START,
    SW.SESSION_END,
    DATEDIFF('second', SW.SESSION_START, SW.SESSION_END) AS SESSION_DURATION_SECONDS,
    SW.TOTAL_EVENTS_IN_SESSION,
    QC.QUERY_ID,
    QC.QUERY_TEXT,
    QC.QUERY_START_TIME,
    QC.EXECUTION_TIME_MS,
    QC.ROWS_RETURNED,
    QC.QUERY_STATUS,
    QC.ERROR_MESSAGE,
    QC.QUERY_SEQUENCE_IN_SESSION,
    DATEDIFF('second', UE.TIMESTAMP, QC.QUERY_START_TIME) AS SECONDS_EVENT_TO_QUERY,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM USER_EVENTS AS UE
    INNER JOIN SESSION_WINDOWS AS SW ON UE.SESSION_ID = SW.SESSION_ID
    LEFT JOIN QUERY_CORRELATION
        AS QC ON UE.SESSION_ID = QC.SESSION_ID
    AND UE.TIMESTAMP <= QC.QUERY_START_TIME
    AND QC.QUERY_START_TIME <= DATEADD('second', 30, UE.TIMESTAMP);  -- Link queries within 30 seconds of events

-- Dynamic Table 5: USER_FUNNEL_ANALYSIS
CREATE OR REPLACE DYNAMIC TABLE USER_FUNNEL_ANALYSIS
TARGET_LAG = '30 minutes'  -- Can have higher lag for funnel analysis
WAREHOUSE = 'COMPUTE_WH'
COMMENT = 'Dynamic table for user funnel analysis with automatic aggregation'
AS
WITH
    SESSION_SUMMARY AS (
        SELECT
            DATE_TRUNC('hour', MIN(TIMESTAMP)) AS ANALYSIS_HOUR,
            SESSION_ID,
            USER_ID,
            MIN(TIMESTAMP) AS SESSION_START,
            MAX(TIMESTAMP) AS SESSION_END,
            COUNT(*) AS TOTAL_EVENTS,
            MAX(CASE WHEN WIDGET_LABEL ILIKE '%login%' THEN 1 ELSE 0 END) AS COMPLETED_LOGIN,
            MAX(CASE
                WHEN WIDGET_LABEL ILIKE '%select%' OR USER_ACTION = 'change'
                    THEN 1
                ELSE 0
            END) AS COMPLETED_SELECTION,
            MAX(CASE WHEN WIDGET_LABEL ILIKE '%search%' THEN 1 ELSE 0 END) AS COMPLETED_SEARCH,
            MAX(CASE WHEN WIDGET_LABEL ILIKE '%download%' THEN 1 ELSE 0 END) AS COMPLETED_DOWNLOAD,
            MAX(CASE WHEN USER_ACTION = 'submit' THEN 1 ELSE 0 END) AS COMPLETED_SUBMIT
        FROM USER_EVENTS
        GROUP BY SESSION_ID, USER_ID
    )

SELECT
    ANALYSIS_HOUR,
    SESSION_ID,
    USER_ID,
    SESSION_START,
    SESSION_END,
    TOTAL_EVENTS,
    COMPLETED_LOGIN::BOOLEAN,
    COMPLETED_SELECTION::BOOLEAN,
    COMPLETED_SEARCH::BOOLEAN,
    COMPLETED_DOWNLOAD::BOOLEAN,
    COMPLETED_SUBMIT::BOOLEAN,
    -- Calculate funnel score (0-5 based on completed steps)
    (COMPLETED_LOGIN + COMPLETED_SELECTION + COMPLETED_SEARCH + COMPLETED_DOWNLOAD + COMPLETED_SUBMIT) AS FUNNEL_SCORE,
    -- Determine drop-off stage
    CASE
        WHEN COMPLETED_SUBMIT = 1 THEN 'COMPLETED'
        WHEN COMPLETED_DOWNLOAD = 1 THEN 'DROPPED_AT_SUBMIT'
        WHEN COMPLETED_SEARCH = 1 THEN 'DROPPED_AT_DOWNLOAD'
        WHEN COMPLETED_SELECTION = 1 THEN 'DROPPED_AT_SEARCH'
        WHEN COMPLETED_LOGIN = 1 THEN 'DROPPED_AT_SELECTION'
        ELSE 'DROPPED_AT_LOGIN'
    END AS DROP_OFF_STAGE,
    -- Step numbers (for funnel visualization)
    CASE WHEN COMPLETED_LOGIN = 1 THEN 1 END AS LOGIN_STEP,
    CASE WHEN COMPLETED_SELECTION = 1 THEN 2 END AS SELECTION_STEP,
    CASE WHEN COMPLETED_SEARCH = 1 THEN 3 END AS SEARCH_STEP,
    CASE WHEN COMPLETED_DOWNLOAD = 1 THEN 4 END AS DOWNLOAD_STEP,
    CASE WHEN COMPLETED_SUBMIT = 1 THEN 5 END AS SUBMIT_STEP,
    CURRENT_TIMESTAMP() AS CREATED_AT,
    CURRENT_TIMESTAMP() AS UPDATED_AT
FROM SESSION_SUMMARY;

-- =============================================================================
-- DASHBOARD VIEWS: 
-- =============================================================================

-- Dashboard view for time-based analysis
CREATE OR REPLACE VIEW VW_DASHBOARD_TIME_SERIES AS
SELECT
    ACTIVITY_HOUR,
    ACTIVITY_HOUR AS ACTIVITY_TIMESTAMP,
    UNIQUE_SESSIONS,
    UNIQUE_USERS,
    TOTAL_EVENTS,
    CLICK_EVENTS,
    CHANGE_EVENTS,
    SUBMIT_EVENTS,
    OTHER_EVENTS,
    AVG_EVENTS_PER_SESSION,
    AVG_SESSION_DURATION_MINUTES,
    TOTAL_QUERIES_EXECUTED,
    AVG_QUERY_EXECUTION_TIME_MS,
    QUERY_SUCCESS_RATE_PCT,
    DATE(ACTIVITY_HOUR) AS ACTIVITY_DATE,
    -- Calculate hour-over-hour changes
    LAG(UNIQUE_SESSIONS) OVER (ORDER BY ACTIVITY_HOUR) AS PREV_UNIQUE_SESSIONS,
    LAG(TOTAL_EVENTS) OVER (ORDER BY ACTIVITY_HOUR) AS PREV_TOTAL_EVENTS,
    ROUND((
        (UNIQUE_SESSIONS - LAG(UNIQUE_SESSIONS) OVER (ORDER BY ACTIVITY_HOUR)) * 100.0
        / NULLIF(LAG(UNIQUE_SESSIONS) OVER (ORDER BY ACTIVITY_HOUR), 0)
    ), 2) AS SESSIONS_CHANGE_PCT
FROM HOURLY_USER_ACTIVITY_SUMMARY  -- Now references dynamic table
ORDER BY ACTIVITY_HOUR DESC;

-- Dashboard view for widget analysis
CREATE OR REPLACE VIEW VW_DASHBOARD_WIDGET_ANALYSIS AS
SELECT
    WIDGET_TYPE,
    WIDGET_LABEL,
    SUM(TOTAL_INTERACTIONS) AS TOTAL_INTERACTIONS,
    SUM(CLICK_COUNT) AS TOTAL_CLICKS,
    SUM(CHANGE_COUNT) AS TOTAL_CHANGES,
    COUNT(DISTINCT DATE(SUMMARY_HOUR)) AS ACTIVE_DAYS,
    COUNT(DISTINCT SUMMARY_HOUR) AS ACTIVE_HOURS,
    AVG(AVG_POSITION_IN_SESSION) AS AVG_POSITION_IN_SESSION,
    SUM(UNIQUE_SESSIONS) AS TOTAL_UNIQUE_SESSIONS,
    SUM(UNIQUE_USERS) AS TOTAL_UNIQUE_USERS,
    ROUND(SUM(TOTAL_INTERACTIONS) * 100.0 / NULLIF(SUM(UNIQUE_SESSIONS), 0), 2) AS ENGAGEMENT_RATE_PCT,
    SUM(CASE WHEN SUMMARY_HOUR >= DATEADD('day', -7, CURRENT_TIMESTAMP()) THEN TOTAL_INTERACTIONS ELSE 0 END)
        AS RECENT_INTERACTIONS,
    SUM(CASE WHEN SUMMARY_HOUR >= DATEADD('hour', -24, CURRENT_TIMESTAMP()) THEN TOTAL_INTERACTIONS ELSE 0 END)
        AS LAST_24H_INTERACTIONS
FROM WIDGET_INTERACTION_SUMMARY  -- Now references dynamic table
WHERE SUMMARY_HOUR >= DATEADD('day', -30, CURRENT_TIMESTAMP())
GROUP BY WIDGET_TYPE, WIDGET_LABEL
ORDER BY TOTAL_INTERACTIONS DESC;

-- Dashboard view for session analysis
CREATE OR REPLACE VIEW VW_DASHBOARD_SESSION_ANALYSIS AS
SELECT
    SESSION_DATE,
    SESSION_ID,
    USER_ID,
    COUNT(*) AS EVENT_COUNT,
    MIN(EVENT_TIMESTAMP) AS SESSION_START,
    MAX(EVENT_TIMESTAMP) AS SESSION_END,
    DATEDIFF('minute', MIN(EVENT_TIMESTAMP), MAX(EVENT_TIMESTAMP)) AS SESSION_DURATION_MINUTES,
    COUNT(DISTINCT WIDGET_ID) AS UNIQUE_WIDGETS_INTERACTED,
    COUNT(CASE WHEN USER_ACTION = 'click' THEN 1 END) AS CLICKS_COUNT,
    COUNT(CASE WHEN USER_ACTION = 'change' THEN 1 END) AS CHANGES_COUNT,
    COUNT(CASE WHEN USER_ACTION = 'submit' THEN 1 END) AS SUBMITS_COUNT,
    MAX(CASE WHEN WIDGET_LABEL ILIKE '%login%' THEN 1 ELSE 0 END) AS HAS_LOGIN,
    MAX(CASE WHEN WIDGET_LABEL ILIKE '%search%' THEN 1 ELSE 0 END) AS HAS_SEARCH,
    MAX(CASE WHEN USER_ACTION = 'submit' THEN 1 ELSE 0 END) AS HAS_SUBMIT
FROM USER_SESSION_JOURNEY  -- Now references dynamic table
WHERE SESSION_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY SESSION_DATE, SESSION_ID, USER_ID
ORDER BY SESSION_START DESC;

-- Dashboard view for real-time monitoring
CREATE OR REPLACE VIEW VW_DASHBOARD_REALTIME AS
SELECT
    'today' AS PERIOD,
    COUNT(DISTINCT SESSION_ID) AS SESSIONS_TODAY,
    COUNT(*) AS EVENTS_TODAY,
    AVG(DATEDIFF('minute', MIN(TIMESTAMP), MAX(TIMESTAMP))) AS AVG_SESSION_DURATION_TODAY,
    COUNT(DISTINCT WIDGET_ID) AS WIDGETS_USED_TODAY
FROM USER_EVENTS  -- Now references dynamic table
WHERE EVENT_DATE = CURRENT_DATE()

UNION ALL

SELECT
    'yesterday' AS PERIOD,
    COUNT(DISTINCT SESSION_ID) AS SESSIONS_YESTERDAY,
    COUNT(*) AS EVENTS_YESTERDAY,
    AVG(DATEDIFF('minute', MIN(TIMESTAMP), MAX(TIMESTAMP))) AS AVG_SESSION_DURATION_YESTERDAY,
    COUNT(DISTINCT WIDGET_ID) AS WIDGETS_USED_YESTERDAY
FROM USER_EVENTS
WHERE EVENT_DATE = DATEADD('day', -1, CURRENT_DATE())

UNION ALL

SELECT
    'last_7_days' AS PERIOD,
    COUNT(DISTINCT SESSION_ID) AS SESSIONS_WEEK,
    COUNT(*) AS EVENTS_WEEK,
    AVG(DATEDIFF('minute', MIN(TIMESTAMP), MAX(TIMESTAMP))) AS AVG_SESSION_DURATION_WEEK,
    COUNT(DISTINCT WIDGET_ID) AS WIDGETS_USED_WEEK
FROM USER_EVENTS
WHERE EVENT_DATE >= DATEADD('day', -7, CURRENT_DATE());
